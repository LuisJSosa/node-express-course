1. In this lesson, you created a middleware function called asyncWrapper. Why?

the function asyncWrapper is created as reusable code to run any promise
that returns data and error in orther to avoid repetition and clutter in our code. 


2. Suppose that you want to make sure that both a status code and error
message are send back to the user when they request the URL for a task that
does not exist. Assume that youâ€™ve created a CustomAPIError class and an
error handler that references that class. Complete the code:

const { CustomAPIError } = require('../errors/custom-error')
const getTask = asyncWrapper(async (err, req, res, next) => {
    const {id: taskID} = req.params
    const task = await Task.findOne({ _id: taskID })
    if (!task){
       return res.status(404).json({ msg: `Task ID: ${taskID} not found` })
    }
    res.status(200).json({ task })
})
